{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"laishujie","url":"https://laishujie.github.io"},"pages":[{"title":"tags","date":"2018-09-18T15:06:36.000Z","updated":"2018-09-18T15:06:36.195Z","comments":true,"path":"tags/index.html","permalink":"https://laishujie.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MPandroidChart LineChart 折线图","slug":"MPAndroidChart LineChart 折线图 你要的都在这里了","date":"2018-05-28T14:05:43.000Z","updated":"2018-09-19T14:24:47.194Z","comments":true,"path":"2018/05/28/MPAndroidChart LineChart 折线图 你要的都在这里了/","link":"","permalink":"https://laishujie.github.io/2018/05/28/MPAndroidChart LineChart 折线图 你要的都在这里了/","excerpt":"前言 &emsp;&emsp;MPAndroidChart已经出了很长的一段时间，相信大家也有所耳闻，自己也使用了有一段时间，固在此写下文章，根据项目的需求，记录一些见解与问题，作为参考。望大家取其精华去其糟粕。","text":"前言 &emsp;&emsp;MPAndroidChart已经出了很长的一段时间，相信大家也有所耳闻，自己也使用了有一段时间，固在此写下文章，根据项目的需求，记录一些见解与问题，作为参考。望大家取其精华去其糟粕。 最终效果图 ######涉及到的问题以及知识点 图表样式以及基础数据 （快速入门） x轴标签自定义标签（Formatting Data Values (ValueFormatter)） 自定义覆盖物（MarkerView） 自定义多个覆盖物（MarkerView） 默认选中覆盖物（Highlighting Values） 线条的隐藏以及显示（visible） 实现左右滑动 数据更新 当前演示 Demo 快速入门1.编写布局文件 12345&lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;195dp&quot; /&gt; 2.实例化并且，设置x轴和y轴的点 123456mLineChart = findViewById(R.id.chart);//1.设置x轴和y轴的点List&lt;Entry&gt; entries = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 12; i++) entries.add(new Entry(i, new Random().nextInt(300))); 3 .把数据赋值到你的线条 1LineDataSet dataSet = new LineDataSet(entries, &quot;Label&quot;); // add entries to dataset 4.设置数据刷新图表 1234//3.chart设置数据 LineData lineData = new LineData(dataSet); mLineChart.setData(lineData); mLineChart.invalidate(); // refresh 很简单吧，但是离我们的效果图还差了好多现在我们开始完善样式,一步一步去设置 样式设置1.线条样式 1234LineDataSet dataSet = new LineDataSet(entries, &quot;Label&quot;); // add entries to dataset dataSet.setColor(Color.parseColor(&quot;#7d7d7d&quot;));//线条颜色 dataSet.setCircleColor(Color.parseColor(&quot;#7d7d7d&quot;));//圆点颜色 dataSet.setLineWidth(1f);//线条宽度 2.x和y轴样式 123456789101112131415161718//设置样式 YAxis rightAxis = mLineChart.getAxisRight(); //设置图表右边的y轴禁用 rightAxis.setEnabled(false); YAxis leftAxis = mLineChart.getAxisLeft(); //设置图表左边的y轴禁用 leftAxis.setEnabled(false); //设置x轴 XAxis xAxis = mLineChart.getXAxis(); xAxis.setTextColor(Color.parseColor(&quot;#333333&quot;)); xAxis.setTextSize(11f); xAxis.setAxisMinimum(0f); xAxis.setDrawAxisLine(true);//是否绘制轴线 xAxis.setDrawGridLines(false);//设置x轴上每个点对应的线 xAxis.setDrawLabels(true);//绘制标签 指x轴上的对应数值 xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);//设置x轴的显示位置 xAxis.setGranularity(1f);//禁止放大后x轴标签重绘 3.隐藏图例与描述 12345678910//透明化图例Legend legend = mLineChart.getLegend();legend.setForm(Legend.LegendForm.NONE);legend.setTextColor(Color.WHITE);//隐藏x轴描述Description description = new Description();description.setEnabled(false);mLineChart.setDescription(description); 4.填充数据 123456//chart设置数据 LineData lineData = new LineData(dataSet); //是否绘制线条上的文字 lineData.setDrawValues(false); mLineChart.setData(lineData); mLineChart.invalidate(); // refresh 效果图 是不是已经很接近效果图了，我们在格式化一下x轴标签 x轴标签自定义标签（Formatting Data Values (ValueFormatter)）格式化x轴标签有好几种方式，这里说两个方法1.要么自己实现接口的方式 1234567XAxis xAxis = mLineChart.getXAxis();xAxis.setValueFormatter(new IAxisValueFormatter() &#123; @Override public String getFormattedValue(float value, AxisBase axis) &#123; return String.valueOf((int) value + 1).concat(&quot;月&quot;); &#125; &#125;); 2.要么用库已经写好的类 1234567//准备好每个点对应的x轴数值List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 12; i++) &#123; list.add(String.valueOf(i+1).concat(&quot;月&quot;)); &#125; XAxis xAxis = mLineChart.getXAxis(); xAxis.setValueFormatter(new IndexAxisValueFormatter(list)); 格式化Y轴也是同样的道理 效果图 ##自定义覆盖物（MarkerView） (1) 继承MarkerView复写其中的方法就OJBK了 直接上代码解释吧 -v- 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class DetailsMarkerView extends MarkerView &#123; private TextView mTvMonth; private TextView mTvChart1; /** * 在构造方法里面传入自己的布局以及实例化控件 * @param context 上下文 * @param 自己的布局 */ public DetailsMarkerView(Context context, int layoutResource) &#123; super(context, layoutResource); mTvMonth = findViewById(R.id.tv_chart_month); mTvChart1 = findViewById(R.id.tv_chart_1); &#125; //每次重绘，会调用此方法刷新数据 @Override public void refreshContent(Entry e, Highlight highlight) &#123; super.refreshContent(e, highlight); try &#123; //收入 if (e.getY() == 0) &#123; mTvChart1.setText(&quot;暂无数据&quot;); &#125; else &#123; mTvChart1.setText(concat(e.getY(), &quot;支出：&quot;)); &#125; mTvMonth.setText(String.valueOf((int) e.getX() + 1).concat(&quot;月&quot;)); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; super.refreshContent(e, highlight); &#125; //布局的偏移量。就是布局显示在圆点的那个位置 // -(width / 2) 布局水平居中 //-(height) 布局显示在圆点上方 @Override public MPPointF getOffset() &#123; return new MPPointF(-(getWidth() / 2), -getHeight()); &#125; public String concat(float money, String values) &#123; return values + new BigDecimal(money).setScale(2, BigDecimal.ROUND_HALF_UP).toPlainString() + &quot;元&quot;; &#125;&#125; (2) 设置覆盖物 1234DetailsMarkerView detailsMarkerView = new DetailsMarkerView(this);//一定要设置这个玩意，不然到点击到最边缘的时候不会自动调整布局detailsMarkerView.setChartView(mLineChart);mLineChart.setDetailsMarkerView(detailsMarkerView); 效果图 自定义多个覆盖物（MarkerView） 接下来我们继续完善，达到下面的效果图 要达到上面的效果,我们可以把它当作3个覆盖物就是这个意思 1.先定义好3个覆盖物，DetailsMarkerView（详情），PositionMarker （中间的标杆）RoundMarker（圆点） 123class DetailsMarkerView extends MarkerView&#123;...&#125;class PositionMarker extends MarkerView&#123;...&#125;class RoundMarkerextends MarkerView&#123;...&#125; 2.继承LineChart，重写drawMarkers 方法。我们直接把drawMarkers方法直接复制下来，加上自己所需要的MarkerView，然后计算它们的位置即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MyLineChart extends LineChart &#123; //弱引用覆盖物对象,防止内存泄漏,不被回收 private WeakReference&lt;DetailsMarkerView&gt; mDetailsReference; private WeakReference&lt;RoundMarker&gt; mRoundMarkerReference; private WeakReference&lt;PositionMarker&gt; mPositionMarkerReference; /** * 所有覆盖物是否为空 * * @return TRUE FALSE */ public boolean isMarkerAllNull() &#123; return mDetailsReference.get() == null &amp;&amp; mRoundMarkerReference.get() == null &amp;&amp; mPositionMarkerReference.get() == null; &#125; public void setDetailsMarkerView(DetailsMarkerView detailsMarkerView) &#123; mDetailsReference = new WeakReference&lt;&gt;(detailsMarkerView); &#125; public void setRoundMarker(RoundMarker roundMarker) &#123; mRoundMarkerReference = new WeakReference&lt;&gt;(roundMarker); &#125; public void setPositionMarker(PositionMarker positionMarker) &#123; mPositionMarkerReference = new WeakReference&lt;&gt;(positionMarker); &#125; /** 复制父类的 drawMarkers方法，并且更换上自己的markerView * draws all MarkerViews on the highlighted positions */ protected void drawMarkers(Canvas canvas) &#123; DetailsMarkerView mDetailsMarkerView = mDetailsReference.get(); RoundMarker mRoundMarker = mRoundMarkerReference.get(); PositionMarker mPositionMarker = mPositionMarkerReference.get(); // if there is no marker view or drawing marker is disabled if (mDetailsMarkerView == null || mRoundMarker == null || mPositionMarker == null || !isDrawMarkersEnabled() || !valuesToHighlight()) return; for (int i = 0; i &lt; mIndicesToHighlight.length; i++) &#123; Highlight highlight = mIndicesToHighlight[i]; IDataSet set = mData.getDataSetByIndex(highlight.getDataSetIndex()); Entry e = mData.getEntryForHighlight(mIndicesToHighlight[i]); int entryIndex = set.getEntryIndex(e); // make sure entry not null if (e == null || entryIndex &gt; set.getEntryCount() * mAnimator.getPhaseX()) continue; float[] pos = getMarkerPosition(highlight); LineDataSet dataSetByIndex = (LineDataSet) getLineData().getDataSetByIndex(highlight.getDataSetIndex()); // check bounds if (!mViewPortHandler.isInBounds(pos[0], pos[1])) continue; float circleRadius = dataSetByIndex.getCircleRadius(); //pos[0], pos[1] x 和 y // callbacks to update the content mDetailsMarkerView.refreshContent(e, highlight); mDetailsMarkerView.draw(canvas, pos[0], pos[1] - mPositionMarker.getHeight()); mPositionMarker.refreshContent(e, highlight); mPositionMarker.draw(canvas, pos[0] - mPositionMarker.getWidth() / 2, pos[1] - mPositionMarkerl.getHeight()); mRoundMarker.refreshContent(e, highlight); mRoundMarker.draw(canvas, pos[0] - mRoundMarker.getWidth() / 2, pos[1] + circleRadius - mRoundMarker.getHeight()); &#125;｝ 设置覆盖物 activity主要代码 12345678910111213141516171819202122232425262728293031323334protected void onCreate(Bundle savedInstanceState) &#123; ...... //点击图表坐标监听 mLineChart.setOnChartValueSelectedListener(new OnChartValueSelectedListener() &#123; @Override public void onValueSelected(Entry e, Highlight h) &#123; //查看覆盖物是否被回收 if (mLineChart.isMarkerAllNull()) &#123; //重新绑定覆盖物 createMakerView(); //并且手动高亮覆盖物 mLineChart.highlightValue(h); &#125; &#125; @Override public void onNothingSelected() &#123; &#125; &#125;); ......&#125; /** * 创建覆盖物 */ public void createMakerView() &#123; DetailsMarkerView detailsMarkerView = new DetailsMarkerView(this); detailsMarkerView.setChartView(mLineChart); mLineChart.setDetailsMarkerView(detailsMarkerView); mLineChart.setPositionMarker(new PositionMarker(this)); mLineChart.setRoundMarker(new RoundMarker(this)); &#125; 这样就大功告成啦！！ ##默认显示覆盖物（Highlighting Values） 可以通过上面的方法，默认显示覆盖物，比如 12//默认显示第一个覆盖物mLineChart.highlightValue(0,0); 线条的隐藏以及显示（Highlighting Values）可以通过LineChart对象获取到线条LineDataSet实体类。然后调用LineDataSet.setVisible(true或者false);，进行隐藏或显示 1mLineChart.getLineData().getDataSets().get(0).setVisible(true); ##左右滑动，并动态切换放大倍数 代码 12345678//x放大5倍 1f代表不放大mLineChart.zoomToCenter(5, 1f);//切记如果要动态的更换倍数，或者还原倍数一定要调用下面的这个方法停止惯性滑动//不然在拖动过程当中是无法更换倍数BarLineChartTouchListener barLineChartTouchListener = (BarLineChartTouchListener) mLineChart.getOnTouchListener(); barLineChartTouchListener.stopDeceleration(); ##更新数据 主要的逻辑: 准备要更新的数据源 检查是否有LineDataSet 存在 有，则通过LineDataSet 的setValues更换整个坐标，或者 data.addEntry(…) 添加一个或者 data.removeEntry(…)删除一个。 无，则创建LineDataSet ,重新构造数据源 调用mLineChart.invalidate();更新图表 代码实例：1234567891011121314151617181920212223242526272829//1,准备要更换的数据 List&lt;Entry&gt; entries = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 12; i++) entries.add(new Entry(i, new Random().nextInt(300))); //2. 获取LineDataSet线条数据集 List&lt;ILineDataSet&gt; dataSets = mLineChart.getLineData().getDataSets(); //是否存在 if (dataSets != null &amp;&amp; dataSets.size() &gt; 0) &#123; //直接更换数据源 for (ILineDataSet set : dataSets) &#123; LineDataSet data = (LineDataSet) set; data.setValues(entries); &#125; &#125; else &#123; //重新生成LineDataSet线条数据集 LineDataSet dataSet = new LineDataSet(entries, &quot;Label&quot;); // add entries to dataset dataSet.setDrawCircles(false); dataSet.setColor(Color.parseColor(&quot;#7d7d7d&quot;));//线条颜色 dataSet.setCircleColor(Color.parseColor(&quot;#7d7d7d&quot;));//圆点颜色 dataSet.setLineWidth(1f);//线条宽度 LineData lineData = new LineData(dataSet); //是否绘制线条上的文字 lineData.setDrawValues(false); mLineChart.setData(lineData); &#125; //更新 mLineChart.invalidate(); 完折线图的内容暂时就那么多，如果有不懂的可以留言,希望可以帮到大家。 最后附上 Demo","categories":[],"tags":[]},{"title":"Android常见的上滑渐变显示标题栏","slug":"Android常见的上滑渐变显示标题栏","date":"2017-08-08T06:25:22.000Z","updated":"2018-09-19T15:12:19.396Z","comments":true,"path":"2017/08/08/Android常见的上滑渐变显示标题栏/","link":"","permalink":"https://laishujie.github.io/2017/08/08/Android常见的上滑渐变显示标题栏/","excerpt":"前言* ~(￣0￣)/， 最近发现很多的APP都有标题渐变的效果，于是就想着写一篇文章记录记录。废话少说，直接上动图 ，看看市面上常见的上滑渐变的标题栏。dd","text":"前言* ~(￣0￣)/， 最近发现很多的APP都有标题渐变的效果，于是就想着写一篇文章记录记录。废话少说，直接上动图 ，看看市面上常见的上滑渐变的标题栏。dd 小米商场和淘宝电影 分析 相信大家也有过这种需求.其实这很简单。我们可以通过这个 控件.setAlpha(percent);方法去达到上图的效果。 参数范围是 0~1 还有个方法是 setBackgroundColor(Color.argb( alpha, red, green, bule)); 参数也很简单 alpha 透明度 0~255 其他的值就是RGB值。如果不知道直接的RGB值怎么拿。可以通过一些小工具获取 演示 可以通过上图查看其值的变化。 总结无论怎样其中的思想就是监听滑动。然后通过api去改变其透明度。 setBackgroundColor(Color.argb(alpha,red,green,bule)); setAlpha(percent); 两者之间选择api一个使用即可。 接下来靠大家自己去实践才会更清楚哦。正所谓 如马克思所说： 实践才是检验真理的唯一标准。啧啧。【完】 Demo","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://laishujie.github.io/tags/android/"}]}]}